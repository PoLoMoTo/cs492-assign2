CS-492-B Assignment 2: Keith Morel and Corey Barnwell
 
FIFO would have a complexity of O(1) where N is the total number of programs in memory since all it has to do is replace the 'first in' with the page needed to be read. LRU would have a complexity of O(N) since it has to search all of the programs in memory to check which one is the oldest. Clock would have a complexity of O(N) since if all the R bits are 1, it then becomes FIFO and removes the first one it passed. Although FIFO does have the least complexity by far, it does suffer badly when it comes to page faults. Since it's not taking into account which programs have been read recently, it could be removing the most used page multiple times. Clock is a much improved version of FIFO in terms of page faults, since it checks to see if the page has been read in the last cycle of the 'clock'. However, LRU is definitely the best in terms of page faults. While quite similar to clock, it takes into account the last use of each page. So although it has to search all of the pages, it does this so it will remove the page that hasn't been used in the longest time.
 
    As expected, FIFO performs quite badly with demand paging and a small page size but much better the bigger the page size gets. Also as expected, with pre-paging FIFO performs worse the bigger the page size because although FIFO is fast, it has many more page faults to deal with, so it is doing double work for each page fault. Clock, as expected, performs much better than FIFO for both demand and pre-paging. With demand paging, clock steadily decreases the amount of page faults as the pages get larger. With pre-paging, clock starts off basically at a floor, so it doesn't decrease the amount of page faults much, but stays consistent. However, once the pages get to a size of 16 with pre-paging, the amount of page faults spikes. This could most likely be described as an ineffieciency peak, meaning that the page size and amount of pages were just right to make it inefficient at this point. As we tested this with larger page sizes, the page faults went back down with larger page sizes like before. LRU performs very much the same as clock, since it is essentially doing the same thing, just fractionally better since it has the actual 'clock time' that the page was last used, instead of just whether or not it was used in the last cycle.
 
    With a completely random memory access trace, pre-paging would be all but useless since it operates on the notion that if you are using one page, you would probably want to use the next one as well. With a random trace, this would almost certainly not be the case given a large number of pages. Demand paging would most likely not be affected much if at all by random memory access trace since it doesn't rely on pages that are close together being used at the same time. Also, page size would have less of an impact on the number of page faults since, like pre-paging, wants to group similar pages together. With random memory access trace, this would not necessarily be the case.

Graphs are in the screen grab, they were generated in the LibreCalc .ods file with the numbers generated from 'make test' in the test.txt file